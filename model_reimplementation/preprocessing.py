# -*- coding: utf-8 -*-
"""preprocessing.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SgYw77YeTW82t4V5M0Cunwb2HE6TTp_6
"""

import pandas as pd
import random
import numpy as np


#to load dataset
from google.colab import drive
drive.mount('/content/drive')

 """
        Prepares dataset with base and auxiliary features, simulating haphazard input conditions.

        Args:
            name (str): dataset name (only "magic04" supported)
            type (str): "trapezoidal" or "variable_p" for masking
            aux_feat_prob (float): probability an aux feature is present (only used in "variable_p")
            use_cuda (bool): unused currently, placeholder for device control.

        Returns:
            n_base_feat (int)
            n_aux_feat (int)
            X_base (np.ndarray)
            X_aux (np.ndarray)
            X_aux_masked (np.ndarray)
            aux_mask (np.ndarray)
            Y (np.ndarray)
            label (np.ndarray)
 """

def dataset(name="magic04", type= "variable_p", aux_feat_prob = 0.5, use_cuda = False):
        data_path = "/content/drive/MyDrive/ColabNotebooks/auxdrop/magic04.data"
        total_features = 10
        n_aux_feat = 8
        n_base_feat = 2

        #reading data
        data_initial =  pd.read_csv(data_path, sep=",", header=None)

        num_samples = data_initial.shape[0]
        data_shuffled = data_initial.sample(frac = 1)
        label = np.array(data_shuffled[total_features] == "g")*1
        data = data_shuffled.iloc[: , :total_features]
        data.insert(0, column='class', value=label)


        # Masking
        # type1 Trapezoidal: auxiliary features are gradually revealed over time (or samples)
        if type == "trapezoidal":
                num_chunks = 10
                chunk_size = num_samples//num_chunks
                aux_mask = np.zeros((num_samples, n_aux_feat))
                aux_feat_per_chunk = [max(0, round((total_features / num_chunks) * i) - n_base_feat)
                              for i in range(1, num_chunks + 1)]
                for i in range(num_chunks):
                        aux_mask[chunk_size*i:chunk_size*(i+1), :aux_feat_per_chunk[i]] = 1

        #Type2 Random: Randomly mask auxiliary feature per sample with probability (1 - aux_feat_prob)
        elif type == "variable_p":
                aux_mask = (np.random.random((num_samples, n_aux_feat)) < aux_feat_prob).astype(float)
        else:
                raise ValueError("Invalid mask type. Choose from 'trapezoidal' or 'variable_p'.")


        # Data division
        Y = np.array(data.iloc[:,:1])
        X_base = np.array(data.iloc[:,1:n_base_feat+1])
        X_aux = np.array(data.iloc[:,n_base_feat+1:], dtype = float)
        X_aux_masked = X_aux * aux_mask

        return n_base_feat, n_aux_feat,  X_base, X_aux, X_aux_masked, aux_mask, Y, label


#n_base_feat - no. of base features
#n_aux_features - no. of auxiliary features
#X_base - base feature values of all the samples
#X_aux - auxiliary feature values of all the samples
#X_aux_masked - X_aux is masked with aux_mask to imitate real world data (haphazard inputs)
#Y - labels